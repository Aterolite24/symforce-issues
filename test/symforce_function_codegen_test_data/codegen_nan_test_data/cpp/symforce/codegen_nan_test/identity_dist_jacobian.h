// -----------------------------------------------------------------------------
// This file was autogenerated by symforce. Do NOT modify by hand.
// -----------------------------------------------------------------------------
#pragma once

#include <Eigen/Dense>

#include <geo/rot3.h>


namespace codegen_nan_test {


/**
* This function was autogenerated. Do not modify by hand.
*
* Arg type(s): Rot3, Symbol
* Return type(s): Add
*
*/
template <typename Scalar>
Scalar IdentityDistJacobian(const geo::Rot3<Scalar>& R1, const Scalar e) {
    // Input arrays
    const Eigen::Matrix<Scalar, 4, 1>& _R1 = R1.Data();

    // Intermediate terms (12)
    const Scalar _tmp0 = (_R1[0] * _R1[0]);
    const Scalar _tmp1 = e - 1;
    const Scalar _tmp2 = -e + 1;
    const Scalar _tmp3 = std::min<Scalar>(_R1[3], _tmp2);
    const Scalar _tmp4 = std::max<Scalar>(_tmp1, _tmp3);
    const Scalar _tmp5 = std::acos(_tmp4);
    const Scalar _tmp6 = -(_R1[3] * _R1[3]);
    const Scalar _tmp7 = std::max<Scalar>(e, _tmp6 + 1);
    const Scalar _tmp8 = 2*_tmp5*((((-_R1[3] + _tmp2) > 0) - ((-_R1[3] + _tmp2) < 0)) + 1)*((((-_tmp1 + _tmp3) > 0) - ((-_tmp1 + _tmp3) < 0)) + 1)/(_tmp7*std::sqrt(-(_tmp4 * _tmp4) + 1));
    const Scalar _tmp9 = 4*_R1[3]*(_tmp5 * _tmp5)*((((_tmp2 + _tmp6) > 0) - ((_tmp2 + _tmp6) < 0)) + 1)/(_tmp7 * _tmp7);
    const Scalar _tmp10 = (_R1[2] * _R1[2]);
    const Scalar _tmp11 = (_R1[1] * _R1[1]);

    // Output terms (1)
    Scalar _dist_D_R1;

    _dist_D_R1 = -_tmp0*_tmp8 + _tmp0*_tmp9 - _tmp10*_tmp8 + _tmp10*_tmp9 - _tmp11*_tmp8 + _tmp11*_tmp9;


    return _dist_D_R1;
}

}  // namespace codegen_nan_test
