# -----------------------------------------------------------------------------
# This file was autogenerated by symforce from template:
#     cc_sym.pyi.jinja
# Do NOT modify by hand.
# -----------------------------------------------------------------------------

from lcmtypes.sym._key_t import key_t
from lcmtypes.sym._index_entry_t import index_entry_t
from lcmtypes.sym._index_t import index_t
from lcmtypes.sym._linearized_dense_factor_t import linearized_dense_factor_t
from lcmtypes.sym._optimization_iteration_t import optimization_iteration_t
from lcmtypes.sym._optimization_stats_t import optimization_stats_t
from lcmtypes.sym._optimizer_params_t import optimizer_params_t
from lcmtypes.sym._values_t import values_t

from sym import Rot2
from sym import Rot3
from sym import Pose2
from sym import Pose3

import scipy
from __future__ import annotations
import cc_sym
import typing
import numpy

__all__ = [
    "Factor",
    "Key",
    "Linearization",
    "OptimizationStats",
    "Optimizer",
    "Values",
    "default_optimizer_params",
    "optimize",
]

class Factor:
    @typing.overload
    def __init__(
        self,
        hessian_func: typing.Callable[[Values, typing.List[index_entry_t]], tuple],
        keys: typing.List[Key],
    ) -> None: ...
    @typing.overload
    def __init__(
        self,
        hessian_func: typing.Callable[[Values, typing.List[index_entry_t]], tuple],
        keys_to_func: typing.List[Key],
        keys_to_optimize: typing.List[Key],
    ) -> None: ...
    def __repr__(self) -> str: ...
    def all_keys(self) -> typing.List[Key]: ...
    @staticmethod
    @typing.overload
    def jacobian(
        jacobian_func: typing.Callable[[Values, typing.List[index_entry_t]], tuple],
        keys: typing.List[Key],
    ) -> Factor: ...
    @staticmethod
    @typing.overload
    def jacobian(
        jacobian_func: typing.Callable[[Values, typing.List[index_entry_t]], tuple],
        keys_to_func: typing.List[Key],
        keys_to_optimize: typing.List[Key],
    ) -> Factor: ...
    def linearize(self, arg0: Values) -> tuple: ...
    def linearized_factor(self, values: Values) -> linearized_dense_factor_t: ...
    def optimized_keys(self) -> typing.List[Key]: ...
    pass

class Key:
    def __eq__(self, arg0: object) -> bool: ...
    def __hash__(self) -> int: ...
    @typing.overload
    def __init__(self, letter: str) -> None: ...
    @typing.overload
    def __init__(self, letter: str, sub: int) -> None: ...
    @typing.overload
    def __init__(self, letter: str, sub: int, super: int) -> None: ...
    def __repr__(self) -> str: ...
    def get_lcm_type(self) -> key_t: ...
    def lexical_less_than(self, arg0: Key) -> bool: ...
    @staticmethod
    def with_super(key: Key, super: int) -> Key: ...
    @property
    def letter(self) -> str:
        """
        :type: str
        """
    @property
    def sub(self) -> int:
        """
        :type: int
        """
    @property
    def super(self) -> int:
        """
        :type: int
        """
    pass

class Linearization:
    def __init__(self) -> None: ...
    def error(self) -> float: ...
    def is_initialized(self) -> bool: ...
    def linear_error(self, x_update: numpy.ndarray) -> float: ...
    def reset(self) -> None: ...
    def set_initialized(self, initialized: bool = True) -> None: ...
    @property
    def hessian_lower(self) -> scipy.sparse.csc_matrix[numpy.float64]:
        """
        :type: scipy.sparse.csc_matrix[numpy.float64]
        """
    @hessian_lower.setter
    def hessian_lower(self, arg0: scipy.sparse.csc_matrix[numpy.float64]) -> None:
        pass
    @property
    def jacobian(self) -> scipy.sparse.csc_matrix[numpy.float64]:
        """
        :type: scipy.sparse.csc_matrix[numpy.float64]
        """
    @jacobian.setter
    def jacobian(self, arg0: scipy.sparse.csc_matrix[numpy.float64]) -> None:
        pass
    @property
    def residual(self) -> numpy.ndarray:
        """
        :type: numpy.ndarray
        """
    @residual.setter
    def residual(self, arg0: numpy.ndarray) -> None:
        pass
    @property
    def rhs(self) -> numpy.ndarray:
        """
        :type: numpy.ndarray
        """
    @rhs.setter
    def rhs(self, arg0: numpy.ndarray) -> None:
        pass
    pass

class OptimizationStats:
    def __init__(self) -> None: ...
    def get_lcm_type(self) -> optimization_stats_t: ...
    @property
    def best_index(self) -> int:
        """
        :type: int
        """
    @best_index.setter
    def best_index(self, arg0: int) -> None:
        pass
    @property
    def best_linearization(self) -> object:
        """
        :type: object
        """
    @best_linearization.setter
    def best_linearization(self, arg1: Linearization) -> None:
        pass
    @property
    def early_exited(self) -> bool:
        """
        :type: bool
        """
    @early_exited.setter
    def early_exited(self, arg0: bool) -> None:
        pass
    @property
    def iterations(self) -> typing.List[optimization_iteration_t]:
        """
        :type: typing.List[optimization_iteration_t]
        """
    @iterations.setter
    def iterations(self, arg0: typing.List[optimization_iteration_t]) -> None:
        pass
    pass

class Optimizer:
    def __init__(
        self,
        params: optimizer_params_t,
        factors: typing.List[Factor] = ...,
        epsilon: float = ...,
        name: str = ...,
        keys: typing.List[Key] = ...,
        debug_stats: bool = ...,
        check_derivatives: bool = ...,
    ) -> None: ...
    def compute_all_covariances(
        self, linearization: Linearization
    ) -> typing.Dict[Key, numpy.ndarray]: ...
    def compute_covariances(
        self, linearization: Linearization, keys: typing.List[Key]
    ) -> typing.Dict[Key, numpy.ndarray]: ...
    def keys(self) -> typing.List[Key]: ...
    def linearize(self, values: Values) -> Linearization: ...
    @typing.overload
    def optimize(
        self, values: Values, num_iterations: int = -1, populate_best_linearization: bool = False
    ) -> OptimizationStats: ...
    @typing.overload
    def optimize(
        self,
        values: Values,
        num_iterations: int,
        populate_best_linearization: bool,
        stats: OptimizationStats,
    ) -> None: ...
    @typing.overload
    def optimize(self, values: Values, num_iterations: int, stats: OptimizationStats) -> None: ...
    @typing.overload
    def optimize(self, values: Values, stats: OptimizationStats) -> None: ...
    def update_params(self, params: optimizer_params_t) -> None: ...
    pass

class Values:
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, msg: values_t) -> None: ...
    def __repr__(self) -> str: ...
    @typing.overload
    def at(self, entry: index_entry_t) -> typing.Any: ...
    @typing.overload
    def at(self, key: Key) -> typing.Any: ...
    def cleanup(self) -> int: ...
    def create_index(self, keys: typing.List[Key]) -> index_t: ...
    def data(self) -> typing.List[float]: ...
    def empty(self) -> bool: ...
    def get_lcm_type(self) -> values_t: ...
    def has(self, key: Key) -> bool: ...
    def items(self) -> typing.Dict[Key, index_entry_t]: ...
    def keys(self, sort_by_offset: bool = True) -> typing.List[Key]: ...
    def local_coordinates(
        self, others: Values, index: index_t, epsilon: float
    ) -> numpy.ndarray: ...
    def num_entries(self) -> int: ...
    def remove(self, key: Key) -> bool: ...
    def remove_all(self) -> None: ...
    def retract(self, index: index_t, delta: typing.List[float], epsilon: float) -> None: ...
    @typing.overload
    def set(self, key: Key, value: Pose2) -> bool: ...
    @typing.overload
    def set(self, key: Key, value: Pose3) -> bool: ...
    @typing.overload
    def set(self, key: Key, value: Rot2) -> bool: ...
    @typing.overload
    def set(self, key: Key, value: Rot3) -> bool: ...
    @typing.overload
    def set(self, key: Key, value: float) -> bool: ...
    @typing.overload
    def set(self, key: Key, value: numpy.ndarray) -> bool: ...
    @typing.overload
    def set(self, key: index_entry_t, value: Pose2) -> None: ...
    @typing.overload
    def set(self, key: index_entry_t, value: Pose3) -> None: ...
    @typing.overload
    def set(self, key: index_entry_t, value: Rot2) -> None: ...
    @typing.overload
    def set(self, key: index_entry_t, value: Rot3) -> None: ...
    @typing.overload
    def set(self, key: index_entry_t, value: float) -> None: ...
    @typing.overload
    def set(self, key: index_entry_t, value: numpy.ndarray) -> None: ...
    @typing.overload
    def update(self, index: index_t, other: Values) -> None: ...
    @typing.overload
    def update(self, index_this: index_t, index_other: index_t, other: Values) -> None: ...
    def update_or_set(self, index: index_t, other: Values) -> None: ...
    pass

def default_optimizer_params() -> optimizer_params_t:
    pass

def optimize(
    params: optimizer_params_t, factors: typing.List[Factor], values: Values, epsilon: float = 1e-09
) -> OptimizationStats:
    pass
