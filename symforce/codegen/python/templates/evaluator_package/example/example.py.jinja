
from __future__ import print_function

# Add the generated package to the path
import os
import sys
sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..'))

import {{ spec.name }}


{% set input_keys = spec.types['input_t']['keys_recursive'] -%}
{% set output_keys = spec.types['output_t']['keys_recursive'] -%}

def main(verbose=False):
    """
    Usage example for the symforce evaluator: "{{ spec.name }}"
    Feel free to copy and modify this.

    Args:
        verbose (bool): Prints are disabled by default to not spam the unit test.
    """
    # --------------------------------------------------------------------------
    # Evaluator usage
    # --------------------------------------------------------------------------

    # Create evaluator
    evaluator = {{ spec.name }}.Evaluator()

    # Create input and fill the first attribute
    inp = evaluator.input_t()
    inp.{{ input_keys[0] }} = 1.0

    # Execute to compute output
    out = evaluator.execute(inp)

    # Print first attribute of output
    if verbose:
        print('out.{{ output_keys[0] }}: {}'.format(out.{{ output_keys[0] }}))

    # --------------------------------------------------------------------------
    # StorageOps usage
    # --------------------------------------------------------------------------

    # Get storage dimension
    if verbose:
        print('input storage dim: {}, output storage dim: {}'.format(
            inp.STORAGE_DIM, out.STORAGE_DIM))

    # Serialize type into a vector
    input_array = inp.to_storage()
    assert len(input_array) == inp.STORAGE_DIM
    if verbose:
        for i, v in enumerate(input_array):
            print('input_array[{}] = {}'.format(i, v))

    # Re-assemble type from the vector
    inp2 = evaluator.input_t.from_storage(input_array)
    assert inp.{{ input_keys[0] }} == inp2.{{ input_keys[0] }}


if __name__ == '__main__':
    main()
