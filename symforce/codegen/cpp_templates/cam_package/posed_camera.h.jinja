{%- import "../util/util.jinja" as util with context -%}

//  -----------------------------------------------------------------------------
// This file was autogenerated by symforce. Do NOT modify by hand.
// -----------------------------------------------------------------------------
#pragma once

#include <Eigen/Dense>
#include <geo/pose3.h>
#include <cam/camera.h>

namespace cam {

/**
{% for line in doc.cls.split('\n') %}
 *{{ ' {}'.format(line).rstrip() }}
{% endfor %}
 */
template <typename CameraCalType>
class PosedCamera : public Camera<CameraCalType> {
 public:
  using Scalar = typename CameraCalType::Scalar;

  PosedCamera(const geo::Pose3<Scalar>& pose, const CameraCalType& calibration, const Eigen::Vector2i& image_size=Eigen::Vector2i(-1, -1))
    : Camera<CameraCalType>(calibration, image_size),
      pose_(pose) {}
  {{ util.print_docstring(doc.pixel_coords_from_global_point) | indent(2) }}
  Eigen::Matrix<Scalar, 2, 1> PixelCoordsFromGlobalPoint(const Eigen::Matrix<Scalar, 3, 1>& point, const Scalar epsilon, Scalar* const is_valid) const {
    const Eigen::Matrix<Scalar, 3, 1> camera_point = pose_.Inverse() * point;
    const Eigen::Matrix<Scalar, 2, 1> pixel_coords = Camera<CameraCalType>::PixelCoordsFromCameraPoint(camera_point, epsilon, is_valid);
    return pixel_coords;
  }
  {{ util.print_docstring(doc.global_point_from_pixel_coords) | indent(2) }}
  Eigen::Matrix<Scalar, 3, 1> GlobalPointFromPixelCoords(const Eigen::Matrix<Scalar, 2, 1>& pixel_coords, Scalar range_to_point, const Scalar epsilon, Scalar* const is_valid) const {
    const Eigen::Matrix<Scalar, 3, 1> camera_ray = Camera<CameraCalType>::CameraRayFromPixelCoords(pixel_coords, epsilon, is_valid);
    const Eigen::Matrix<Scalar, 3, 1> camera_point = range_to_point * camera_ray.normalized();
    const Eigen::Matrix<Scalar, 3, 1> global_point = pose_ * camera_point;
    return global_point;
  }

  const geo::Pose3<Scalar>& Pose() const {
    return pose_;
  }

  private:
    geo::Pose3<Scalar> pose_;
};

}  // namespace cam
