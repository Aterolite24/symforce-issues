{%- import "../util/util.jinja" as util with context -%}

//  -----------------------------------------------------------------------------
// This file was autogenerated by symforce. Do NOT modify by hand.
// -----------------------------------------------------------------------------
#pragma once

#include <Eigen/Dense>
#include <geo/pose3.h>
#include <cam/camera.h>

namespace cam {

/**
{% for line in doc.cls.split('\n') %}
 *{{ ' {}'.format(line).rstrip() }}
{% endfor %}
 */
template <typename CameraCalType>
class PosedCamera : public Camera<CameraCalType> {
 public:
  using Scalar = typename CameraCalType::Scalar;

  PosedCamera(const geo::Pose3<Scalar>& pose, const CameraCalType& calibration, const Eigen::Vector2i& image_size=Eigen::Vector2i(-1, -1))
    : Camera<CameraCalType>(calibration, image_size),
      pose_(pose) {}
  {{ util.print_docstring(doc.pixel_from_global_point) | indent(2) }}
  Eigen::Matrix<Scalar, 2, 1> PixelFromGlobalPoint(const Eigen::Matrix<Scalar, 3, 1>& point, const Scalar epsilon, Scalar* const is_valid) const {
    const Eigen::Matrix<Scalar, 3, 1> camera_point = pose_.Inverse() * point;
    const Eigen::Matrix<Scalar, 2, 1> pixel = Camera<CameraCalType>::PixelFromCameraPoint(camera_point, epsilon, is_valid);
    return pixel;
  }
  {{ util.print_docstring(doc.global_point_from_pixel) | indent(2) }}
  Eigen::Matrix<Scalar, 3, 1> GlobalPointFromPixel(const Eigen::Matrix<Scalar, 2, 1>& pixel, Scalar range_to_point, const Scalar epsilon, Scalar* const is_valid) const {
    const Eigen::Matrix<Scalar, 3, 1> camera_ray = Camera<CameraCalType>::CameraRayFromPixel(pixel, epsilon, is_valid);
    const Eigen::Matrix<Scalar, 3, 1> camera_point = range_to_point * camera_ray.normalized();
    const Eigen::Matrix<Scalar, 3, 1> global_point = pose_ * camera_point;
    return global_point;
  }

  {{ util.print_docstring(doc.warp_pixel) | indent(2) }}
  Eigen::Matrix<Scalar, 2, 1> WarpPixel(const Eigen::Matrix<Scalar, 2, 1>& pixel, Scalar inverse_range, const PosedCamera& target_cam, const Scalar epsilon, Scalar* const is_valid) const {
    if (inverse_range == 0) {
      Scalar is_valid_ray;
      const Eigen::Matrix<Scalar, 3, 1> camera_ray_self = Camera<CameraCalType>::CameraRayFromPixel(pixel, epsilon, &is_valid_ray);
      const Eigen::Matrix<Scalar, 3, 1> camera_ray_target = target_cam.Pose().Rotation().Inverse() * (pose_.Rotation() * camera_ray_self);
      Scalar is_valid_projection;
      const Eigen::Matrix<Scalar, 2, 1> target_pixel = target_cam.PixelFromCameraPoint(camera_ray_target, epsilon, &is_valid_projection);
      *is_valid = is_valid_ray * is_valid_projection;
      return target_pixel;
    }

    Scalar is_valid_point;
    const Eigen::Matrix<Scalar, 3, 1> global_point = GlobalPointFromPixel(
        pixel, 1 / (inverse_range + epsilon), epsilon, &is_valid_point
    );
    Scalar is_valid_projection;
    const Eigen::Matrix<Scalar, 2, 1> target_pixel = target_cam.PixelFromGlobalPoint(global_point, epsilon, &is_valid_projection);

    *is_valid = is_valid_point * is_valid_projection;
    return target_pixel;
  }

  const geo::Pose3<Scalar>& Pose() const {
    return pose_;
  }

  private:
    geo::Pose3<Scalar> pose_;
};

}  // namespace cam
