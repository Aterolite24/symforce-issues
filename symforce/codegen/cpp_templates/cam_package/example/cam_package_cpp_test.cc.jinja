//  -----------------------------------------------------------------------------
// This file was autogenerated by symforce. Do NOT modify by hand.
//
// Instead modify:
//     symforce/codegen/cpp/templates/cam_package/example/cam_package_cpp_test.cc.jinja
//
// And then run `symforce_cam_codegen_test --update`.
// -----------------------------------------------------------------------------
/**
 * Tests for C++ camera types. Mostly checking all the templates compile since
 * the math is tested comprehensively in symbolic form.
 */

#include <iostream>
#include <Eigen/Dense>

{% for cls in all_types %}
#include <cam/{{ camelcase_to_snakecase(cls.__name__) }}.h>
{% endfor %}

// TODO(hayk): Use the catch unit testing framework (single header).
#define assertTrue(a)                                      \
  if (!(a)) {                                              \
    std::ostringstream o;                                  \
    o << __FILE__ << ":" << __LINE__ << ": Test failure."; \
    throw std::runtime_error(o.str());                     \
  }

template <typename T>
void TestStorageOps() {
  using Scalar = typename T::Scalar;

  Eigen::Matrix<Scalar, geo::StorageOps<T>::StorageDim(), 1> data = Eigen::Matrix<Scalar, geo::StorageOps<T>::StorageDim(), 1>::Random();

  const T value(data);
  std::cout << "*** Testing StorageOps: " << value << " ***" << std::endl;

  constexpr int32_t storage_dim = geo::StorageOps<T>::StorageDim();
  assertTrue(value.Data().rows() == storage_dim);
  assertTrue(value.Data().cols() == 1);

  std::vector<Scalar> vec;
  value.ToStorage(&vec);
  assertTrue(vec.size() > 0);
  assertTrue(vec.size() == storage_dim);
  for (int i = 0; i < vec.size(); ++i) {
    assertTrue(vec[i] == value.Data()[i]);
  }

  const T value2 = geo::StorageOps<T>::FromStorage(vec);
  assertTrue(value.Data() == value2.Data());
  vec[0] = 2.1;
  const T value3 = geo::StorageOps<T>::FromStorage(vec);
  assertTrue(value.Data() != value3.Data());
}

template <typename T>
void TestProjectDeproject() {
  using Scalar = typename T::Scalar;

  Eigen::Matrix<Scalar, geo::StorageOps<T>::StorageDim(), 1> data = Eigen::Matrix<Scalar, geo::StorageOps<T>::StorageDim(), 1>::Random();

  T cam(data);
  std::cout << "*** Testing projection model: " << cam << " ***" << std::endl;

  Scalar epsilon = 1e-6;
  Scalar is_valid;

  Eigen::Matrix<Scalar, 2, 1> pixel_coords = Eigen::Matrix<Scalar, 2, 1>::Random();
  Eigen::Matrix<Scalar, 3, 1> camera_ray = cam.CameraRayFromPixelCoords(pixel_coords, epsilon, &is_valid);
  Eigen::Matrix<Scalar, 2, 1> pixel_coords_reprojected = cam.PixelCoordsFromCameraPoint(camera_ray, epsilon, &is_valid);
  assertTrue(pixel_coords.isApprox(pixel_coords_reprojected, epsilon));
}

int main(int argc, char** argv) {
  {% for scalar in scalar_types %}
  {% for cls in all_types %}
  TestStorageOps<cam::{{ cls.__name__ }}<{{ scalar }}>>();
  TestProjectDeproject<cam::{{ cls.__name__ }}<{{ scalar }}>>();
  {% endfor %}
  {% endfor %}

}
