  // --------------------------------------------------------------------------
  // Handwritten methods for Rot3
  // --------------------------------------------------------------------------

  // Quaternion

  Eigen::Quaternion<Scalar> Quaternion() const {
    return Eigen::Quaternion<Scalar>(data_.data());
  }

  explicit Rot3(const Eigen::Quaternion<Scalar>& q) : Rot3(q.coeffs()) {}

  static Rot3 FromQuaternion(const Eigen::Quaternion<Scalar>& q) {
    return Rot3(q);
  }

  // Angle-axis

  Eigen::AngleAxis<Scalar> AngleAxis() const {
    return Eigen::AngleAxis<Scalar>(Quaternion());
  }

  explicit Rot3(const Eigen::AngleAxis<Scalar>& aa) : Rot3(Eigen::Quaternion<Scalar>(aa)) {}

  static Rot3 FromAngleAxis(const Eigen::AngleAxis<Scalar>& aa) {
    return Rot3(aa);
  }

  static Rot3 FromAngleAxis(const Scalar angle, const Vector3& axis) {
    return Rot3(Eigen::AngleAxis<Scalar>(angle, axis));
  }

  // Rotation matrix

  // Note: ToRotationMatrix is autogenerated below

  static Rot3 FromRotationMatrix(const Eigen::Matrix<Scalar, 3, 3>& mat) {
    return Rot3(Eigen::Quaternion<Scalar>(mat));
  }

  // Euler angles
  // TODO(hayk): Could codegen this.

  Vector3 YawPitchRoll() const {
      return ToRotationMatrix().eulerAngles(2, 1, 0);
  }

  static Rot3 FromYawPitchRoll(const Scalar yaw, const Scalar pitch, const Scalar roll) {
      return Rot3(Eigen::AngleAxis<Scalar>(yaw, Vector3::UnitZ()) *
                  Eigen::AngleAxis<Scalar>(pitch, Vector3::UnitY()) *
                  Eigen::AngleAxis<Scalar>(roll, Vector3::UnitX()));
  }

  static Rot3 FromYawPitchRoll(const Vector3& ypr) {
      return FromYawPitchRoll(ypr[0], ypr[1], ypr[2]);
  }

  // TODO(hayk): Could codegen this.
  Vector3 Compose(const Vector3& point) const {
      return Quaternion() * point;
  }

  // This function was autogenerated from the symbolic function:
  //    geo.Rot3.random_from_uniform_samples
  static Rot3 RandomFromUniformSamples(const Scalar u1, const Scalar u2, const Scalar u3) {
    // Output array
    Eigen::Matrix<Scalar, 4, 1> res;

    // Intermediate terms (7)
    const Scalar _tmp0 = 2*M_PI;
    const Scalar _tmp1 = _tmp0*u2;
    const Scalar _tmp2 = std::sqrt(u1);
    const Scalar _tmp3 = _tmp0*u3;
    const Scalar _tmp4 = _tmp2*std::cos(_tmp3);
    const Scalar _tmp5 = (((_tmp4) > 0) - ((_tmp4) < 0));
    const Scalar _tmp6 = _tmp5*std::sqrt(1 - u1);

    // Output terms (4)
    res[0] = _tmp6*std::sin(_tmp1);
    res[1] = _tmp6*std::cos(_tmp1);
    res[2] = _tmp2*_tmp5*std::sin(_tmp3);
    res[3] = _tmp4*_tmp5;

    return Rot3(res);
  }

  // Generate a random element in SO3
  static Rot3 Random(std::mt19937& gen) {
    std::uniform_real_distribution<Scalar> dist(0.0, 1.0);
    return RandomFromUniformSamples(dist(gen), dist(gen), dist(gen));
  }

  // Flip the quaternion if needed to give a positive real part (w).
  // This can be useful for comparing rotations where double cover is an issue.
  Rot3 ToPositiveReal() const {
    if (Data()[3] < 0) {
      return Rot3(-Data());
    } else {
      return Rot3(Data());
    }
  }
