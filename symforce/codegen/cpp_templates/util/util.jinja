{# ------------------------------------------------------------------------- #}
{# Utilities for C++ code generation templates.                              #}
{# ------------------------------------------------------------------------- #}

{# Vector type of a given dimension
 #
 # Args:
 #     dim (int):
 #}
{%- macro vector_type(dim) -%}
Eigen::Matrix<Scalar, {{ dim }}, 1>
{%- endmacro -%}

{# ------------------------------------------------------------------------- #}

{# Matrix type of a given dimension
 #
 # Args:
 #     rows (int):
 #     cols (int):
 #}
{%- macro matrix_type(rows, cols) -%}
Eigen::Matrix<Scalar, {{ rows }}, {{ cols }}>
{%- endmacro -%}

{# ------------------------------------------------------------------------- #}

{# Convert a class to the emitted string
 #
 # Args:
 #     T_or_value (type or Element):
 #     name (str): Optional name in case type is a generated struct
 #}
{%- macro format_typename(T_or_value, name="") %}
    {%- set T = python_util.get_type(T_or_value) -%}
    {%- if T.__name__ == 'Symbol' or is_symbolic(T_or_value) -%}
        Scalar
    {%- elif T.__name__ == 'NoneType' -%}
        void
    {%- elif issubclass(T, Matrix) -%}
        {{ matrix_type(T_or_value.shape[0], T_or_value.shape[1]) }}
    {%- elif issubclass(T, Values) -%}
        {{ spec.namespaces_dict[name] }}::{{ spec.typenames_dict[name] }}
    {%- elif is_sequence(T_or_value) -%}
        std::array<{{ format_typename(T_or_value[0], name) }}, {{ T_or_value | length }}>
    {%- else -%}
        {%- if "geo" in T.__module__ -%}
        geo::
        {%- elif "cam" in T.__module__ -%}
        cam::
        {%- endif -%}
        {{- T.__name__ -}}<Scalar>
    {%- endif -%}
{% endmacro -%}

{# ------------------------------------------------------------------------- #}

{# Get the type of the object in the ouput Values with key given by spec.return_key
 #
 # Args:
 #     spec (Codegen):
 #}
{%- macro get_return_type(spec) %}
    {%- if spec.return_key is not none -%}
        {{ format_typename(spec.outputs[spec.return_key], spec.return_key) }}
    {%- else -%}
        void
    {%- endif -%}
{% endmacro -%}

{# ------------------------------------------------------------------------- #}

 {# Format function docstring
 #
 # Args:
 #     docstring (str):
 #}
{% macro print_docstring(docstring) %}
{%- if docstring %}

/*
{%- for line in docstring.split('\n') %}
*{{ ' {}'.format(line).rstrip() }}
{% endfor -%}
*/
{%- endif -%}
{% endmacro %}

{# ------------------------------------------------------------------------- #}

{# Format function input argument
 #
 # Args:
 #     T_or_value (type or Element):
 #     name (str):
 #}
{%- macro format_input_arg(T_or_value, name) %}
    {%- set T = python_util.get_type(T_or_value) -%}
    {% if T == Symbol -%}
        {#- Scalar type is just const -#}
        const {{ format_typename(T_or_value) }} {{ name }}
    {%- else -%}
        {#- Otherwise assume const reference -#}
        const {{ format_typename(T_or_value, name) }}& {{ name }}
    {%- endif %}
{% endmacro -%}

{# ------------------------------------------------------------------------- #}

{# Format function pointer argument
 #
 # Args:
 #     T_or_value (type or Element):
 #     name (str):
 #}
{%- macro format_pointer_arg(T_or_value, name) %}
    {{- format_typename(T_or_value, name) -}}* const {{ name -}}
{% endmacro -%}

{# ------------------------------------------------------------------------- #}

{# Generate input arguments declaration.
 #
 # Args:
 #     spec (Codegen):
 #}
{%- macro input_args_declaration(spec) %}
    {%- for name, type in spec.inputs.items() -%}
        {%- if name != "self" -%}
            {{ format_input_arg(type, name) }}
            {%- if not loop.last
                or spec.outputs.items() | length > 1
                or (spec.outputs.items() | length == 1 and spec.return_key is none) -%}
            , {% endif -%}
        {%- endif -%}
    {%- endfor -%}
    {%- for name, type in spec.outputs.items() -%}
        {%- if name != spec.return_key -%}
            {{- format_pointer_arg(type, name) -}}
            {%- if not loop.last -%}
                {%- if not (loop.revindex0 == 1 and loop.nextitem[0] == spec.return_key) -%}
                , {% endif -%}
            {% endif -%}
        {%- endif -%}
    {%- endfor -%}
{% endmacro -%}

{# ------------------------------------------------------------------------- #}

{# Generate function declaration
 #
 # Args:
 #     spec (Codegen):
 #}
{%- macro function_declaration(spec) -%}
{{ get_return_type(spec) }} {{ spec.name }}({{- input_args_declaration(spec) -}})
{%- endmacro -%}

{# ------------------------------------------------------------------------- #}

{# Generate function declaration with custom namespace
 #
 # Args:
 #     spec (Codegen):
 #     namespace (str):
 #}
{%- macro function_declaration_custom_namespace(spec, namespace) -%}
{{ get_return_type(spec) }} {{ namespace }}::{{ spec.name }}({{- input_args_declaration(spec) -}})
{%- endmacro -%}

{# ------------------------------------------------------------------------- #}

{# Generate inner code for computing the given expression.
 #
 # Args:
 #     spec (Codegen):
 #}
{% macro expr_code(spec) -%}
    // Input arrays
    {% for name, type in spec.inputs.items() %}
        {% set T = python_util.get_type(type) %}
        {% if not issubclass(T, Values) and not issubclass(T, Matrix) and not is_symbolic(type) and not is_sequence(type) %}
            {% if name == "self" %}
    const {{ vector_type(ops.StorageOps.storage_dim(type)) }}& _{{ name }} = Data();
            {% else %}
    const {{ vector_type(ops.StorageOps.storage_dim(type)) }}& _{{ name }} = {{ name }}.Data();
            {% endif %}
        {% endif %}
    {% endfor %}
    {% for name, type in spec.outputs.items() %}
        {% if name != spec.return_key %}
    assert( {{ name }} != nullptr );
        {% endif %}
    {% endfor %}

    // Intermediate terms ({{ spec.intermediate_terms | length }})
    {% for lhs, rhs in spec.intermediate_terms %}
    const {{ format_typename(Symbol) }} {{ lhs }} = {{ rhs }};
    {% endfor %}

    // Output terms ({{ spec.outputs.items() | length }})
    {# Populate the output vectors with the generated expressions #}
    {% for name, type in spec.outputs.items() %}
        {% set T = python_util.get_type(type) %}
        {% if issubclass(T, Matrix) or issubclass(T, Values) or is_symbolic(type) or is_sequence(type) %}
            {% set T_return = python_util.get_type(type) %}
            {% if name == spec.return_key and T_return.__name__ != 'NoneType' %}
                {# Create a new object to return #}
    {{ format_typename(type, name) }} _{{ name }};
            {% else %}
                {# Get reference to output passed by reference #}
    {{ format_typename(type, name) }}& _{{ name }} = (*{{ name }});
            {% endif %}
        {% else %}
            {# geo/cam object. Since we can't access individual element of data, create a copy #}
            {# TODO(nathan): Maybe add a [] operator to geo/cam objects so we don't have to do this? #}
            {% set dims = ops.StorageOps.storage_dim(type) %}
    {{ vector_type(dims) }} _{{ name }};
        {% endif %}
    {% endfor %}

    {% for lhs, rhs in spec.output_terms %}
    _{{ lhs }} = {{ rhs }};
    {% endfor %}

    {% for name, type in spec.outputs.items() %}
        {% set T = python_util.get_type(type) %}
        {% if name != spec.return_key %}
            {% if not issubclass(T, Matrix) and not issubclass(T, Values) and not is_symbolic(type) and not is_sequence(type) %}
    *{{ name }} = {{ format_typename(type, name) }}(_{{ name }});
            {% endif %}
        {% endif %}
    {% endfor %}

    {% for name, type in spec.outputs.items() %}
        {% set T_return = python_util.get_type(type) %}
        {% if name == spec.return_key and T_return.__name__ != 'NoneType' %}
            {%- if issubclass(T_return, Matrix) or issubclass(T_return, Values) or is_symbolic(type) or is_sequence(type) %}
    return _{{ name }};
            {%- else %}
    return {{ format_typename(type, name) }}(_{{ name }});
            {%- endif -%}
        {%- endif -%}
    {%- endfor -%}
{%- endmacro -%}
