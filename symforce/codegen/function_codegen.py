# mypy: disallow-untyped-defs

import inspect
import os
import textwrap

from symforce import sympy as sm
from symforce import geo
from symforce import python_util
from symforce import ops
from symforce import types as T

from . import codegen_util
from . import template_util


def common_data():
    # type: () -> T.Dict[str, T.Any]
    """
    Return common template data for code generation.
    """
    data = {}  # type: T.Dict[str, T.Any]
    data["ops"] = ops
    data["Symbol"] = sm.Symbol
    data["Matrix"] = geo.Matrix
    data["scalar_types"] = ("double", "float")
    data["camelcase_to_snakecase"] = python_util.camelcase_to_snakecase

    return data


class FunctionCodegen(object):
    """
    Code generation for a symbolic function. This is the most lightweight codegen path.
    """

    def __init__(
        self,
        name,  # type: str
        func,  # type: T.Callable
        arg_types,  # type: T.Sequence[T.Any]
        return_type,  # type: T.Any
        doc=None,  # type: str
    ):
        """
        Args:
            name: Name of generated function
            func: Function that takes symbolic arguments
            arg_types: Types of arguments to func
            return_type: Return value of func
            doc: If given, use this docstring. Else, get from func.
        """
        self.name = name
        self.func = func
        self.arg_types = arg_types
        self.return_type = return_type

        # Match function arguments and names with provided types
        # NOTE(hayk): This switch is for python 3 compatibility.
        try:
            self.arg_spec = inspect.getfullargspec(func)  # type: ignore
        except AttributeError:
            self.arg_spec = inspect.getargspec(func)  # type: ignore

        assert len(self.arg_spec.args) == len(self.arg_types)
        self.args = list(zip(self.arg_spec.args, arg_types))

        # Pull docstring out of function if not provided, and strip indentation
        if doc is None:
            if func.__doc__:
                doc = func.__doc__
            else:
                doc = self._default_docstring()
        self.doc = textwrap.dedent(doc).strip()

        # Code will be generated on request
        self.intermediate_terms = None  # type: T.Optional[T.Sequence[T.Tuple[str, str]]]
        self.output_terms = None  # type: T.Optional[T.Sequence[str]]

    def _default_docstring(self):
        # type: () -> str
        """
        Create a default docstring if no other is available from the function or caller.
        """
        return """
        This function was autogenerated from the symbolic function:

        Name: {}
        Args: ({})
        Returns: {}
        """.format(
            self.func.__name__,
            ", ".join([ops.StorageOps.get_type(arg).__name__ for arg in self.arg_types]),
            ops.StorageOps.get_type(self.return_type).__name__,
        )

    def compute_symbolic_result(self):
        # type: () -> T.Tuple[T.Scalar, T.List[T.Any]]
        """
        Create symbolic arguments to the function, and invoke it to get the symbolic result.

        Returns:
            (Expr): Symbolic result of func
            (iterable(type)): Symbolic objects per input argument
        """
        symbolic_args = []

        for i, arg_type in enumerate(self.arg_types):
            # Get the dimension
            storage_dim = ops.StorageOps.storage_dim(arg_type)

            # Name scalars differently
            # TODO(hayk): Use StorageOps.symbolic and change names in template?
            arg_cls = geo.StorageOps.get_type(arg_type)
            if arg_cls == sm.Symbol:
                name_str = "{}"
            elif arg_cls == geo.Matrix:
                name_str = "{}[{}]"
            else:
                # For a geo type, we extract the .data() with an underscore prefix
                # to keep the argument as the original variable name.
                name_str = "_{}[{}]"

            # Create symbols
            symbols = [
                sm.Symbol(name_str.format(self.arg_spec.args[i], j)) for j in range(storage_dim)
            ]

            # Construct the type
            symbolic_args.append(ops.StorageOps.from_storage(arg_type, symbols))

        # Evaluate the function
        result = self.func(*symbolic_args)

        return result, symbolic_args

    def gen_code(self, mode):
        # type: (codegen_util.CodegenMode) -> None
        """
        Emit the lines of code to compute the result. Saves to self.
        """
        result, _ = self.compute_symbolic_result()
        result_list = ops.StorageOps.to_storage(result)
        expected_dim = ops.StorageOps.storage_dim(self.return_type)
        actual_dim = len(result_list)
        assert actual_dim == expected_dim, "Expected dim {}, got {}".format(
            expected_dim, actual_dim
        )

        self.intermediate_terms, self.output_terms = codegen_util.print_code(
            input_symbols=[], output_exprs=result_list, mode=mode, substitute_inputs=False,
        )

    def render(self, mode, output_path=None):
        # type: (codegen_util.CodegenMode, str) -> str
        """
        Generate the entire function as code. Return the code as a string,
        and save to a file if given a path.
        """
        if self.intermediate_terms is None:
            self.gen_code(mode=mode)

        if mode == codegen_util.CodegenMode.CPP:
            template_path = os.path.join(
                template_util.CPP_TEMPLATE_DIR, "function/function.h.jinja"
            )
        elif mode == codegen_util.CodegenMode.PYTHON2:
            template_path = os.path.join(
                template_util.PYTHON_TEMPLATE_DIR, "function/function.py.jinja"
            )
        else:
            raise NotImplementedError('Unknown mode: "{}"'.format(mode))

        return template_util.render_template(
            template_path=template_path,
            output_path=output_path,
            data=dict(common_data(), spec=self),
        )
