import inspect
import os
import textwrap

from symforce import sympy as sm
from symforce import geo
from symforce import python_util
from symforce import ops

from . import codegen_util
from . import template_util


def common_data():
    """
    Return common template data for code generation.

    Returns:
        dict:
    """
    data = {}
    data["ops"] = ops
    data["Symbol"] = sm.Symbol
    data["Matrix"] = geo.Matrix
    data["scalar_types"] = ("double", "float")
    data["camelcase_to_snakecase"] = python_util.camelcase_to_snakecase

    return data


class FunctionCodegen(object):
    """
    Code generation for a symbolic function. This is the most lightweight codegen path.
    """

    def __init__(self, name, func, arg_types, return_type, doc=None):
        """
        Args:
            name (str): Name of generated function
            func (callable): Function that takes symbolic arguments
            arg_types (iterable(type)): Types of arguments to func
            return_type (type): Return value of func
            doc (str or None): If given, use this docstring. Else, get from func.
        """
        self.name = name
        self.func = func
        self.arg_types = arg_types
        self.return_type = return_type

        # Match function arguments and names with provided types
        self.arg_spec = inspect.getargspec(func)
        assert len(self.arg_spec.args) == len(self.arg_types)
        self.args = list(zip(self.arg_spec.args, arg_types))

        # Pull docstring out of function if not provided, and strip indentation
        if doc is None:
            if func.__doc__:
                doc = func.__doc__
            else:
                doc = self._default_docstring()
        self.doc = textwrap.dedent(doc).strip()

        # Code will be generated on request
        self.intermediate_terms, self.output_terms = None, None

    def _default_docstring(self):
        """
        Create a default docstring if no other is available from the function or caller.

        Returns:
            str:
        """
        return """
        This function was autogenerated from the symbolic function:

        Name: {}
        Args: ({})
        Returns: {}
        """.format(
            self.func.__name__,
            ", ".join([ops.StorageOps.get_type(arg).__name__ for arg in self.arg_types]),
            ops.StorageOps.get_type(self.return_type).__name__,
        )

    def compute_symbolic_result(self):
        """
        Create symbolic arguments to the function, and invoke it to get the symbolic result.

        Returns:
            (Expr): Symbolic result of func
            (iterable(type)): Symbolic objects per input argument
        """
        symbolic_args = []

        for i, arg_type in enumerate(self.arg_types):
            # Get the dimension
            storage_dim = ops.StorageOps.storage_dim(arg_type)

            # Name scalars differently
            # TODO(hayk): Use StorageOps.symbolic and change names in template?
            arg_cls = geo.StorageOps.get_type(arg_type)
            if arg_cls == sm.Symbol:
                name_str = "{}"
            elif arg_cls == geo.Matrix:
                name_str = "{}[{}]"
            else:
                # For a geo type, we extract the .data() with an underscore prefix
                # to keep the argument as the original variable name.
                name_str = "_{}[{}]"

            # Create symbols
            symbols = [
                sm.Symbol(name_str.format(self.arg_spec.args[i], j)) for j in range(storage_dim)
            ]

            # Construct the type
            symbolic_args.append(ops.StorageOps.from_storage(arg_type, symbols))

        # Evaluate the function
        result = self.func(*symbolic_args)

        return result, symbolic_args

    def gen_code(self, mode):
        """
        Emit the lines of code to compute the result. Saves to self.

        Args:
            mode (CodegenMode):
        """
        result, symbolic_args = self.compute_symbolic_result()
        result_list = ops.StorageOps.to_storage(result)
        expected_dim = ops.StorageOps.storage_dim(self.return_type)
        actual_dim = len(result_list)
        assert actual_dim == expected_dim, "Expected dim {}, got {}".format(
            expected_dim, actual_dim
        )

        self.intermediate_terms, self.output_terms = codegen_util.print_code(
            input_symbols=None, output_exprs=result_list, mode=mode, substitute_inputs=False,
        )

    def render(self, mode, output_path=None):
        """
        Generate the entire function as code.

        Args:
            mode (CodegenMode):
            output_path (str or None): If given, save to file.

        Returns:
            str: Function code
        """
        if self.intermediate_terms is None:
            self.gen_code(mode=mode)

        if mode == codegen_util.CodegenMode.CPP:
            template_path = os.path.join(
                template_util.CPP_TEMPLATE_DIR, "function", "function.h.jinja"
            )
        elif mode == codegen_util.CodegenMode.PYTHON2:
            template_path = os.path.join(
                template_util.PYTHON_TEMPLATE_DIR, "function", "function.py.jinja"
            )
        else:
            raise NotImplementedError('Unknown mode: "{}"'.format(mode))

        return template_util.render_template(
            template_path=template_path,
            output_path=output_path,
            data=dict(common_data(), spec=self),
        )
