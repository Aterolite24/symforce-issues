{# ------------------------------------------------------------------------- #}
{# Utilities for C++ code generation templates.                              #}
{# ------------------------------------------------------------------------- #}

{# Vector type of a given dimension
 #
 # Args:
 #     dim (int):
 #}
{%- macro vector_type(dim) -%}
Eigen::Matrix<Scalar, {{ dim }}, 1>
{%- endmacro -%}

{# ------------------------------------------------------------------------- #}

{# Convert a class to the emitted string
 #
 # Args:
 #     T_or_value (type or Element):
 #}
{%- macro format_typename(T_or_value) %}
    {%- set T = ops.StorageOps.get_type(T_or_value) -%}
    {% if issubclass(T, Symbol) -%}
        Scalar
    {%- elif issubclass(T, Matrix) -%}
        {{ vector_type(ops.StorageOps.storage_dim(T_or_value)) }}
    {%- else -%}
        {{ T.__name__ }}<Scalar>
    {%- endif %}
{% endmacro -%}

{# ------------------------------------------------------------------------- #}

{# Format function input argument
 #
 # Args:
 #     T_or_value (type or Element):
 #     name (str):
 #}
{%- macro format_input_arg(T_or_value, name) %}
    {%- set T = ops.StorageOps.get_type(T_or_value) -%}
    {% if T == Symbol -%}
        {#- Scalar type is just const -#}
        const {{ format_typename(T_or_value) }} {{ name }}
    {%- else -%}
        {#- Otherwise assume const reference -#}
        const {{ format_typename(T_or_value) }}& {{ name }}
    {%- endif %}
{% endmacro -%}

{# ------------------------------------------------------------------------- #}

{# Generate inner code for computing the given expression.
 #
 # Args:
 #     spec (FunctionCodegen):
 #}
{% macro expr_code(spec) -%}
// Input arrays
{% for arg, T in spec.args -%}
{% if not issubclass(ops.StorageOps.get_type(T), (Symbol, Matrix)) %}
const {{ vector_type(ops.StorageOps.storage_dim(T)) }}& _{{ arg }} = {{ arg }}.Data();
{% endif %}
{% endfor %}

// Output array
{{ vector_type(spec.output_terms.__len__()) }} res;

// Intermediate terms ({{ spec.intermediate_terms | length }})
{% for lhs, rhs in spec.intermediate_terms %}
const {{ format_typename(Symbol) }} {{ lhs }} = {{ rhs }};
{% endfor %}

// Output terms ({{ spec.output_terms | length }})
{% for line in spec.output_terms %}
res[{{ loop.index - 1 }}] = {{ line }};
{% endfor %}
{% endmacro %}

{# ------------------------------------------------------------------------- #}

{# Generate a C++ template function.
 #
 # Args:
 #     template_name (str):
 #     spec (FunctionCodegen):
 #}
{% macro templated_function(template_name, spec) %}
template <typename Scalar>
{{ format_typename(spec.return_type) }} {{ template_name }}<Scalar>::{{ spec.name }}(
  {%- for arg, type in spec.args -%}
  {{ format_input_arg(type, arg) }}{% if not loop.last %}, {% endif %}
  {%- endfor -%}
) {
    {{ expr_code(spec) | indent(4) }}
    {% set T_return = ops.StorageOps.get_type(spec.return_type) %}
    {% if T_return == cls %}
    return {{ format_typename(spec.return_type) }}(res);
    {% elif issubclass(T_return, Matrix) %}
    return res;
    {% elif issubclass(T_return, Symbol) %}
    return res[0];
    {% endif %}
}
{% endmacro %}
