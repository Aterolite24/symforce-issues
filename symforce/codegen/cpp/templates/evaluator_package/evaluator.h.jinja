// -----------------------------------------------------------------------------
// This file was autogenerated by symforce. Do NOT modify by hand.
// -----------------------------------------------------------------------------
#pragma once

#include <cassert>
#include <cmath>

#include <{{ types_package }}/input_t.h>
#include <{{ types_package }}/output_t.h>
#include <{{ spec.name }}/storage_ops.h>

namespace {{ spec.name }} {

class Evaluator {
 public:
  explicit Evaluator() :
    input_array_(StorageOps::StorageDim<input_t>()),
    output_array_(StorageOps::StorageDim<output_t>()) {}

  static const char* Name() {
    return "{{ spec.name }}";
  }

  void Execute(const input_t& input, output_t* output) {
    assert(output != nullptr);
    StorageOps::ToStorage(input, &input_array_);
    _Execute(input_array_.data(), output_array_.data());
    StorageOps::FromStorage(output_array_, output);
  }

  // Alternate version that avoids a copy using a gross re-interpret cast
  // TODO(hayk): Do timing to decide if the copy is ever meaningful.
  static void Execute2(const input_t& input, output_t* output) {
    const {{ spec.scalar_type }}* input_array = reinterpret_cast<const {{ spec.scalar_type }}*>(&input);
    {{ spec.scalar_type }}* output_array = reinterpret_cast<{{ spec.scalar_type }}*>(output);
    _Execute(input_array, output_array);
  }

 private:
  // Underlying generated code, defined in the cc.
  static void _Execute(const {{ spec.scalar_type }} * inp, {{ spec.scalar_type }}* out);

  std::vector<{{ spec.scalar_type }}> input_array_;
  std::vector<{{ spec.scalar_type }}> output_array_;
};

}  // namespace {{ spec.name }}
