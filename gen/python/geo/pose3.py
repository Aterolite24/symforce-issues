# -----------------------------------------------------------------------------
# This file was autogenerated by symforce. Do NOT modify by hand.
# -----------------------------------------------------------------------------
import numpy as np

from .rot3 import Rot3
from .ops.impl import pose3 as ops


class Pose3(object):
    """"
    Autogenerated Python implementation of <class 'symforce.geometry.pose3.Pose3'>.

    Group of three-dimensional rigid body transformations - rotation and translation.

    The storage is a quaternion (x, y, z, w) for rotation followed by position (x, y, z).

    The tangent space is 3 elements for rotation followed by 3 elements for translation in
    the rotated frame, meaning we interpolate the translation in the body frame for lie
    operations. This can be useful but is more expensive than SO3 x R3 for often no benefit.
    """

    __slots__ = ['storage']

    def __repr__(self):
        return '<{} {}>'.format(self.__class__.__name__, self.storage)

    # --------------------------------------------------------------------------
    # StorageOps concept
    # --------------------------------------------------------------------------

    @staticmethod
    def storage_dim():
        return 7

    def to_list(self):
        return list(self.storage)

    @classmethod
    def from_list(cls, vec):
        instance = cls()

        if isinstance(vec, list):
            instance.storage = vec
        else:
            instance.storage = list(vec)

        assert len(vec) == cls.storage_dim(), '{} has storage dim {}, got {}.'.format(
            cls.__name__, cls.storage_dim(), len(vec))

        return instance

    # --------------------------------------------------------------------------
    # GroupOps concept
    # --------------------------------------------------------------------------

    @classmethod
    def identity(cls):
        return cls.from_list(ops.GroupOps.identity())

    def inverse(self):
        return self.__class__.from_list(ops.GroupOps.inverse(self))

    def compose(self, b):
        return self.__class__.from_list(ops.GroupOps.compose(self, b))

    def between(self, b):
        return self.__class__.from_list(ops.GroupOps.between(self, b))

    # --------------------------------------------------------------------------
    # LieGroupOps concept
    # --------------------------------------------------------------------------

    @staticmethod
    def tangent_dim():
        return 6

    @classmethod
    def expmap(cls, vec, epsilon=1e-8):
        assert len(vec) == cls.tangent_dim(), '{}, {}'.format(len(vec), cls.tangent_dim())
        return cls.from_list(ops.LieGroupOps.expmap(vec, epsilon))

    def logmap(self, epsilon=1e-8):
        return ops.LieGroupOps.logmap(self, epsilon)

    def retract(self, vec, epsilon=1e-8):
        assert len(vec) == cls.tangent_dim(), '{}, {}'.format(len(vec), cls.tangent_dim())
        return self.__class__.from_list(ops.LieGroupOps.retract(self, vec, epsilon))

    def local_coordinates(self, b, epsilon=1e-8):
        return ops.LieGroupOps.local_coordinates(self, b, epsilon)

    # --------------------------------------------------------------------------
    # General Helpers
    # --------------------------------------------------------------------------
    def __eq__(self, other):
        return self.storage == other.storage

    def __mul__(self, other):
        if isinstance(other, self.__class__):
            return self.compose(other)
        else:
            raise NotImplementedError('Cannot compose {} with {}.'.format(type(self), type(other)))

    # Included from "custom_methods/pose3.py":
    # --------------------------------------------------------------------------
    # Handwritten methods for Pose3
    # These will get included into the autogenerated class header.
    # --------------------------------------------------------------------------

    def __init__(self, R=None, t=None):
        rotation = R if R is not None else Rot3()
        position = t if R is not None else [0., 0., 0.]
        assert isinstance(rotation, Rot3)

        self.storage = rotation.to_list() + list(position)

    def rotation(self):
        return Rot3.from_list(self.storage[0:4])

    def position(self):
        return np.array(self.storage[4:7])
