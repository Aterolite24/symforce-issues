# -----------------------------------------------------------------------------
# This file was autogenerated by symforce. Do NOT modify by hand.
# -----------------------------------------------------------------------------
import numpy as np

from .rot3 import Rot3
from .ops import pose3 as ops


class Pose3(object):
    """"
    Autogenerated Python implementation of <class 'symforce.geo.pose3.Pose3'>.

    Group of three-dimensional rigid body transformations - SE(3).

    The storage is a quaternion (x, y, z, w) for rotation followed by position (x, y, z).

    The tangent space is 3 elements for rotation followed by 3 elements for translation in
    the rotated frame, meaning we interpolate the translation in the tangent of the rotating
    frame for lie operations. This can be useful but is more expensive than SO3 x R3 for often
    no benefit.
    """

    __slots__ = ['data']

    def __repr__(self):
        return '<{} {}>'.format(self.__class__.__name__, self.data)

    # --------------------------------------------------------------------------
    # StorageOps concept
    # --------------------------------------------------------------------------

    @staticmethod
    def storage_dim():
        return 7

    def to_storage(self):
        return list(self.data)

    @classmethod
    def from_storage(cls, vec):
        instance = cls()

        if isinstance(vec, list):
            instance.data = vec
        else:
            instance.data = list(vec)

        assert len(vec) == cls.storage_dim(), '{} has storage dim {}, got {}.'.format(
            cls.__name__, cls.storage_dim(), len(vec))

        return instance

    # --------------------------------------------------------------------------
    # GroupOps concept
    # --------------------------------------------------------------------------

    @classmethod
    def identity(cls):
        return cls.from_storage(ops.GroupOps.identity())

    def inverse(self):
        return self.__class__.from_storage(ops.GroupOps.inverse(self))

    def compose(self, b):
        return self.__class__.from_storage(ops.GroupOps.compose(self, b))

    def between(self, b):
        return self.__class__.from_storage(ops.GroupOps.between(self, b))

    # --------------------------------------------------------------------------
    # LieGroupOps concept
    # --------------------------------------------------------------------------

    @staticmethod
    def tangent_dim():
        return 6

    @classmethod
    def from_tangent(cls, vec, epsilon=1e-8):
        assert len(vec) == cls.tangent_dim(), '{}, {}'.format(len(vec), cls.tangent_dim())
        return cls.from_storage(ops.LieGroupOps.from_tangent(vec, epsilon))

    def to_tangent(self, epsilon=1e-8):
        return ops.LieGroupOps.to_tangent(self, epsilon)

    def retract(self, vec, epsilon=1e-8):
        assert len(vec) == self.tangent_dim(), '{}, {}'.format(len(vec), self.tangent_dim())
        return self.__class__.from_storage(ops.LieGroupOps.retract(self, vec, epsilon))

    def local_coordinates(self, b, epsilon=1e-8):
        return ops.LieGroupOps.local_coordinates(self, b, epsilon)

    # --------------------------------------------------------------------------
    # General Helpers
    # --------------------------------------------------------------------------
    def __eq__(self, other):
        return self.data == other.data

    def __mul__(self, other):
        if isinstance(other, self.__class__):
            return self.compose(other)
        else:
            raise NotImplementedError('Cannot compose {} with {}.'.format(type(self), type(other)))

    # Included from "custom_methods/pose3.py.jinja":
    # --------------------------------------------------------------------------
    # Handwritten methods for Pose3
    # These will get included into the autogenerated class header.
    # --------------------------------------------------------------------------

    def __init__(self, R=None, t=None):
        rotation = R if R is not None else Rot3()
        position = t if R is not None else [0., 0., 0.]
        assert isinstance(rotation, Rot3)

        self.data = rotation.to_storage() + list(position)

    def rotation(self):
        return Rot3.from_storage(self.data[0:4])

    def position(self):
        return np.array(self.data[4:7])
