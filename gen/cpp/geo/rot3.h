//  -----------------------------------------------------------------------------
// This file was autogenerated by symforce. Do NOT modify by hand.
// -----------------------------------------------------------------------------
#pragma once

#include <ostream>
#include <vector>
#include <Eigen/Dense>

#include "./ops/storage_ops.h"
#include "./ops/group_ops.h"
#include "./ops/lie_group_ops.h"

namespace geo {

/**
 * Autogenerated C++ implementation of <class 'symforce.geometry.rot3.Rot3'>.
 *
 * Group of three-dimensional orthogonal matrices with determinant +1, representing
 * rotations in 3D space. Backed by a quaternion with (x, y, z, w) storage.
 */
template <typename ScalarType>
class Rot3 {
 public:
  // Typedefs
  using Scalar = ScalarType;
  using Self = Rot3<Scalar>;
  using StorageVec = Eigen::Matrix<Scalar, 4, 1>;
  using TangentVec = Eigen::Matrix<Scalar, 3, 1>;

  // Construct from storage
  explicit Rot3(const StorageVec& storage) : storage_(storage) {}

  // Default construct to identity
  Rot3() : Rot3(GroupOps<Self>::Identity()) {}

  // Access underlying storage as const
  inline const StorageVec& Storage() const {
      return storage_;
  }

  // --------------------------------------------------------------------------
  // StorageOps concept
  // --------------------------------------------------------------------------

  static constexpr int32_t StorageDim() {
    return StorageOps<Self>::StorageDim();
  }

  void ToList(std::vector<Scalar>* vec) const {
    return StorageOps<Self>::ToList(*this, vec);
  }

  static Rot3 FromList(const std::vector<Scalar>& vec) {
    return StorageOps<Self>::FromList(vec);
  }

  // --------------------------------------------------------------------------
  // GroupOps concept
  // --------------------------------------------------------------------------

  static Self Identity() {
    return GroupOps<Self>::Identity();
  }

  Self Inverse() const {
    return GroupOps<Self>::Inverse(*this);
  }

  Self Compose(const Self& b) const {
    return GroupOps<Self>::Compose(*this, b);
  }

  Self Between(const Self& b) const {
    return GroupOps<Self>::Between(*this, b);
  }

  // Compose shorthand
  template <typename Other>
  Other operator*(const Other& b) const {
    return Compose(b);
  }

// --------------------------------------------------------------------------
  // LieGroupOps concept
  // --------------------------------------------------------------------------

  static constexpr int32_t TangentDim() {
    return LieGroupOps<Self>::TangentDim();
  }

  static Self Expmap(const TangentVec& vec, const Scalar epsilon = 1e-8f) {
    return LieGroupOps<Self>::Expmap(vec, epsilon);
  }

  TangentVec Logmap(const Scalar epsilon = 1e-8f) const {
    return LieGroupOps<Self>::Logmap(*this, epsilon);
  }

  Self Retract(const TangentVec& vec, const Scalar epsilon = 1e-8f) const {
    return LieGroupOps<Self>::Retract(*this, vec, epsilon);
  }

  TangentVec LocalCoordinates(const Self& b, const Scalar epsilon = 1e-8f) const {
    return LieGroupOps<Self>::LocalCoordinates(*this, b, epsilon);
  }

  // --------------------------------------------------------------------------
  // General Helpers
  // --------------------------------------------------------------------------

  bool IsApprox(const Self& b, const Scalar tol) const {
    // isApprox is multiplicative so we check the norm for the exact zero case
    // https://eigen.tuxfamily.org/dox/classEigen_1_1DenseBase.html#ae8443357b808cd393be1b51974213f9c
    if (b.Storage() == StorageVec::Zero()) {
      return Storage().norm() < tol;
    }

    return Storage().isApprox(b.Storage(), tol);
  }

  template <typename ToScalar>
  Rot3<ToScalar> Cast() const {
    return Rot3<ToScalar>(Storage().template cast<ToScalar>());
  }

  // Included from "custom_methods/rot3.h":
  // --------------------------------------------------------------------------
  // Handwritten methods for Pose2
  // --------------------------------------------------------------------------

  using Vector3 = Eigen::Matrix<Scalar, 3, 1>;

  // Quaternion

  Eigen::Quaternion<Scalar> Quaternion() const {
      return Eigen::Quaternion<Scalar>(storage_.data());
  }

  explicit Rot3(const Eigen::Quaternion<Scalar>& q) : Rot3(q.coeffs()) {}
  
  static Rot3 FromQuaternion(const Eigen::Quaternion<Scalar>& q) {
      return Rot3(q);
  }
  
  // Angle-axis

  Eigen::AngleAxis<Scalar> AngleAxis() const {
      return Eigen::AngleAxis<Scalar>(Quaternion());
  }

  explicit Rot3(const Eigen::AngleAxis<Scalar>& aa) : Rot3(Eigen::Quaternion<Scalar>(aa)) {}

  static Rot3 FromAngleAxis(const Eigen::AngleAxis<Scalar>& aa) {
      return Rot3(aa);
  }

  static Rot3 FromAngleAxis(const Scalar angle, const Vector3& axis) {
      return Rot3(Eigen::AngleAxis<Scalar>(angle, axis));
  }

  // Rotation matrix

  Eigen::Matrix<Scalar, 3, 3> Matrix() const {
      return Quaternion().toRotationMatrix();
  }
 
  static Rot3 FromMatrix(const Eigen::Matrix<Scalar, 3, 3>& mat) {
      return Rot3(Eigen::Quaternion<Scalar>(mat));
  }

  static Rot3 Random() {
      return Rot3(Eigen::Quaternion<Scalar>::UnitRandom());
  }

  // Euler angles
  // TODO(hayk): Could codegen this.

  Vector3 YawPitchRoll() const {
      return Matrix().eulerAngles(2, 1, 0);
  }

  static Rot3 FromYawPitchRoll(const Scalar yaw, const Scalar pitch, const Scalar roll) {
      return Rot3(Eigen::AngleAxis<Scalar>(yaw, Vector3::UnitZ()) *
                  Eigen::AngleAxis<Scalar>(pitch, Vector3::UnitY()) *
                  Eigen::AngleAxis<Scalar>(roll, Vector3::UnitX()));
  }

  static Rot3 FromYawPitchRoll(const Vector3& ypr) {
      return FromYawPitchRoll(ypr[0], ypr[1], ypr[2]);
  }

  // TODO(hayk): Could codegen this.
  Vector3 Compose(const Vector3& point) const {
      return Quaternion() * point;
  }


 protected:
  StorageVec storage_;
};

// Shorthand for scalar types
using Rot3d = Rot3<double>;
using Rot3f = Rot3<float>;

}  // namespace geo

// Externs to reduce duplicate instantiation
extern template class geo::Rot3<double>;
extern template class geo::Rot3<float>;

// Print definitions
std::ostream& operator<<(std::ostream& os, const geo::Rot3<double>& a);
std::ostream& operator<<(std::ostream& os, const geo::Rot3<float>& a);

// Concept implementations for this class
#include "./ops/impl/rot3/storage_ops.h"
#include "./ops/impl/rot3/group_ops.h"
#include "./ops/impl/rot3/lie_group_ops.h"
