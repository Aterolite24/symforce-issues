//  -----------------------------------------------------------------------------
// This file was autogenerated by symforce. Do NOT modify by hand.
// -----------------------------------------------------------------------------
#pragma once

#include <Eigen/Dense>
#include <geo/pose3.h>
#include <cam/camera.h>

namespace cam {

/**
 * Camera with a given pose, camera calibration, and an optionally specified image size.
 * If the image size is specified, we use it to check whether pixels (either given or computed by
 * projection of 3D points into the image frame) are in the image frame and thus valid/invalid.
 */
template <typename CameraCalType>
class PosedCamera : public Camera<CameraCalType> {
 public:
  using Scalar = typename CameraCalType::Scalar;

  PosedCamera(const geo::Pose3<Scalar>& pose, const CameraCalType& calibration, const Eigen::Vector2i& image_size=Eigen::Vector2i(-1, -1))
    : Camera<CameraCalType>(calibration, image_size),
      pose_(pose) {}
  
  /**
  * Transforms the given point into the camera frame using the given camera pose and then
  * uses the given camera calibration to compute the resulted pixel coordinates of the
  * projected point.
  *
  * Args:
  *     point: Vector written in camera frame.
  *     epsilon: Small value intended to prevent division by 0.
  *
  * Return:
  *     pixel_coords: UV coodinates in pixel units, assuming the point is in view
  *     is_valid: 1 if point is valid
  *
  */
  Eigen::Matrix<Scalar, 2, 1> PixelCoordsFromGlobalPoint(const Eigen::Matrix<Scalar, 3, 1>& point, const Scalar epsilon, Scalar* const is_valid) const {
    const Eigen::Matrix<Scalar, 3, 1> camera_point = pose_.Inverse() * point;
    const Eigen::Matrix<Scalar, 2, 1> pixel_coords = Camera<CameraCalType>::PixelCoordsFromCameraPoint(camera_point, epsilon, is_valid);
    return pixel_coords;
  }
  
  /**
  * Computes a point written in the global frame along the ray passing through the center
  * of the given pixel. The point is positioned at a given range along the ray.
  *
  * Args:
  *     pixel_coords: Vector in pixels in camera image.
  *     range_to_point: Distance of the returned point along the ray passing through pixel_coords
  *     epsilon: Small value intended to prevent division by 0.
  *
  * Return:
  *     global_point: The point in the global frame.
  *     is_valid: 1 if point is valid
  *
  */
  Eigen::Matrix<Scalar, 3, 1> GlobalPointFromPixelCoords(const Eigen::Matrix<Scalar, 2, 1>& pixel_coords, Scalar range_to_point, const Scalar epsilon, Scalar* const is_valid) const {
    const Eigen::Matrix<Scalar, 3, 1> camera_ray = Camera<CameraCalType>::CameraRayFromPixelCoords(pixel_coords, epsilon, is_valid);
    const Eigen::Matrix<Scalar, 3, 1> camera_point = range_to_point * camera_ray.normalized();
    const Eigen::Matrix<Scalar, 3, 1> global_point = pose_ * camera_point;
    return global_point;
  }

  const geo::Pose3<Scalar>& Pose() const {
    return pose_;
  }

  private:
    geo::Pose3<Scalar> pose_;
};

}  // namespace cam
