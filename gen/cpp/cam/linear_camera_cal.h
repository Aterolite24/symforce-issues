//  -----------------------------------------------------------------------------
// This file was autogenerated by symforce. Do NOT modify by hand.
// -----------------------------------------------------------------------------
#pragma once

#include <ostream>
#include <random>
#include <vector>
#include <Eigen/Dense>

#include <geo/ops/storage_ops.h>

namespace cam {

/**
 * Autogenerated C++ implementation of <class 'symforce.cam.linear_camera_cal.LinearCameraCal'>.
 *
 * Standard pinhole camera w/ four parameters [fx, fy, cx, cy].
 * (fx, fy) representing focal length; (cx, cy) representing principal point.
 */
template <typename ScalarType>
class LinearCameraCal {
 public:
  // Typedefs
  using Scalar = ScalarType;
  using Self = LinearCameraCal<Scalar>;
  using DataVec = Eigen::Matrix<Scalar, 4, 1>;

  // Construct from data vec
  explicit LinearCameraCal(const DataVec& data) : data_(data) {}

  // Access underlying storage as const
  inline const DataVec& Data() const {
      return data_;
  }

  // --------------------------------------------------------------------------
  // StorageOps concept
  // --------------------------------------------------------------------------

  static constexpr int32_t StorageDim() {
    return geo::StorageOps<Self>::StorageDim();
  }

  void ToStorage(std::vector<Scalar>* vec) const {
    return geo::StorageOps<Self>::ToStorage(*this, vec);
  }

  static LinearCameraCal FromStorage(const std::vector<Scalar>& vec) {
    return geo::StorageOps<Self>::FromStorage(vec);
  }

  // --------------------------------------------------------------------------
  // Camera model methods
  // --------------------------------------------------------------------------

  /**
  * Return the focal length.
  */
  Eigen::Matrix<Scalar, 2, 1> FocalLength() const;

  /**
  * Return the principal point.
  */
  Eigen::Matrix<Scalar, 2, 1> PrincipalPoint() const;

  /**
  * Project a 3D point in the camera frame into 2D pixel coordinates.
  *
  * Return:
  *     pixel: (x, y) coordinate in pixels if valid
  *     is_valid: 1 if the operation is within bounds else 0
  *
  */
  Eigen::Matrix<Scalar, 2, 1> PixelFromCameraPoint(const Eigen::Matrix<Scalar, 3, 1>& point, const Scalar epsilon, Scalar* const is_valid = nullptr) const;

  /**
  * Backproject a 2D pixel coordinate into a 3D ray in the camera frame.
  *
  * Return:
  *     camera_ray: The ray in the camera frame (NOT normalized)
  *     is_valid: 1 if the operation is within bounds else 0
  *
  */
  Eigen::Matrix<Scalar, 3, 1> CameraRayFromPixel(const Eigen::Matrix<Scalar, 2, 1>& pixel, const Scalar epsilon, Scalar* const is_valid = nullptr) const;

  // --------------------------------------------------------------------------
  // General Helpers
  // --------------------------------------------------------------------------

  bool IsApprox(const Self& b, const Scalar tol) const {
    // isApprox is multiplicative so we check the norm for the exact zero case
    // https://eigen.tuxfamily.org/dox/classEigen_1_1DenseBase.html#ae8443357b808cd393be1b51974213f9c
    if (b.Data() == DataVec::Zero()) {
      return Data().norm() < tol;
    }

    return Data().isApprox(b.Data(), tol);
  }

  template <typename ToScalar>
  LinearCameraCal<ToScalar> Cast() const {
    return LinearCameraCal<ToScalar>(Data().template cast<ToScalar>());
  }

  bool operator==(const LinearCameraCal& rhs) const {
    return data_ == rhs.Data();
  }

 protected:
  DataVec data_;
};

// Shorthand for scalar types
using LinearCameraCald = LinearCameraCal<double>;
using LinearCameraCalf = LinearCameraCal<float>;

}  // namespace cam

// Externs to reduce duplicate instantiation
extern template class cam::LinearCameraCal<double>;
extern template class cam::LinearCameraCal<float>;

// Print definitions
std::ostream& operator<<(std::ostream& os, const cam::LinearCameraCal<double>& a);
std::ostream& operator<<(std::ostream& os, const cam::LinearCameraCal<float>& a);

// Concept implementations for this class
#include "./ops/linear_camera_cal/storage_ops.h"
