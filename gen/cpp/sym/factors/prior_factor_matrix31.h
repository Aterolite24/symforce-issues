// -----------------------------------------------------------------------------
// This file was autogenerated by symforce. Do NOT modify by hand.
// -----------------------------------------------------------------------------
#pragma once

#include <Eigen/Dense>



namespace sym {


/**
* Residual that penalizes the difference between a value and prior (desired / measured value).
*
* In vector space terms that would be:
*     prior - value
*
* In lie group terms:
*     to_tangent(compose(inverse(value), prior))
*
* Args:
*     sqrt_info: Square root information matrix to whiten residual. This can be computed from
*                a covariance matrix as the cholesky decomposition of the inverse. In the case
*                of a diagonal it will contain 1/sigma values. Must match the tangent dim.
*
*/
template <typename Scalar>
void PriorFactorMatrix31(const Eigen::Matrix<Scalar, 3, 1>& value, const Eigen::Matrix<Scalar, 3, 1>& prior, const Eigen::Matrix<Scalar, 3, 3>& sqrt_info, const Scalar epsilon, Eigen::Matrix<Scalar, 3, 1>* const res, Eigen::Matrix<Scalar, 3, 3>* const jac) {
    // Input arrays
    assert( res != nullptr );
    assert( jac != nullptr );

    // Intermediate terms (3)
    const Scalar _tmp0 = -prior(2, 0) + value(2, 0);
    const Scalar _tmp1 = -prior(1, 0) + value(1, 0);
    const Scalar _tmp2 = -prior(0, 0) + value(0, 0);

    // Output terms (2)
    Eigen::Matrix<Scalar, 3, 1>& _res = (*res);
    Eigen::Matrix<Scalar, 3, 3>& _jac = (*jac);

    _res(0, 0) = _tmp0*sqrt_info(0, 2) + _tmp1*sqrt_info(0, 1) + _tmp2*sqrt_info(0, 0);
    _res(1, 0) = _tmp0*sqrt_info(1, 2) + _tmp1*sqrt_info(1, 1) + _tmp2*sqrt_info(1, 0);
    _res(2, 0) = _tmp0*sqrt_info(2, 2) + _tmp1*sqrt_info(2, 1) + _tmp2*sqrt_info(2, 0);
    _jac(0, 0) = sqrt_info(0, 0);
    _jac(0, 1) = sqrt_info(0, 1);
    _jac(0, 2) = sqrt_info(0, 2);
    _jac(1, 0) = sqrt_info(1, 0);
    _jac(1, 1) = sqrt_info(1, 1);
    _jac(1, 2) = sqrt_info(1, 2);
    _jac(2, 0) = sqrt_info(2, 0);
    _jac(2, 1) = sqrt_info(2, 1);
    _jac(2, 2) = sqrt_info(2, 2);



}

}  // namespace sym
