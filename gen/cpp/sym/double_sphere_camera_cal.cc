//  -----------------------------------------------------------------------------
// This file was autogenerated by symforce. Do NOT modify by hand.
// -----------------------------------------------------------------------------

#include "./double_sphere_camera_cal.h"

// Explicit instantiation
template class sym::DoubleSphereCameraCal<double>;
template class sym::DoubleSphereCameraCal<float>;

// Camera operation implementations
namespace sym {

template <typename Scalar>
Eigen::Matrix<Scalar, 2, 1> DoubleSphereCameraCal<Scalar>::FocalLength() const {
  // Total ops: 0

  // Input arrays
  const Eigen::Matrix<Scalar, 6, 1>& _self = Data();

  // Intermediate terms (0)

  // Output terms (1)
  Eigen::Matrix<Scalar, 2, 1> _focal_length;

  _focal_length(0, 0) = _self[0];
  _focal_length(1, 0) = _self[1];

  return _focal_length;
}

template <typename Scalar>
Eigen::Matrix<Scalar, 2, 1> DoubleSphereCameraCal<Scalar>::PrincipalPoint() const {
  // Total ops: 0

  // Input arrays
  const Eigen::Matrix<Scalar, 6, 1>& _self = Data();

  // Intermediate terms (0)

  // Output terms (1)
  Eigen::Matrix<Scalar, 2, 1> _principal_point;

  _principal_point(0, 0) = _self[2];
  _principal_point(1, 0) = _self[3];

  return _principal_point;
}

template <typename Scalar>
Eigen::Matrix<Scalar, 2, 1> DoubleSphereCameraCal<Scalar>::PixelFromCameraPoint(
    const Eigen::Matrix<Scalar, 3, 1>& point, const Scalar epsilon, Scalar* const is_valid) const {
  // Total ops: 91

  // Input arrays
  const Eigen::Matrix<Scalar, 6, 1>& _self = Data();

  // Intermediate terms (13)
  const Scalar _tmp0 = std::pow<Scalar>(epsilon, 2) + std::pow<Scalar>(point(0, 0), 2) +
                       std::pow<Scalar>(point(1, 0), 2);
  const Scalar _tmp1 = std::sqrt(_tmp0 + std::pow<Scalar>(point(2, 0), 2));
  const Scalar _tmp2 = _self[4] * _tmp1 + point(2, 0);
  const Scalar _tmp3 =
      std::min<Scalar>(0, (((_self[5] + Scalar(-0.5)) > 0) - ((_self[5] + Scalar(-0.5)) < 0)));
  const Scalar _tmp4 = 2 * _tmp3;
  const Scalar _tmp5 = _self[5] - epsilon * (_tmp4 + 1);
  const Scalar _tmp6 = -_tmp5;
  const Scalar _tmp7 =
      1.0 /
      (std::max<Scalar>(epsilon, std::fabs(_tmp2 * (_tmp6 + 1) +
                                           _tmp5 * std::sqrt(_tmp0 + std::pow<Scalar>(_tmp2, 2)))));
  const Scalar _tmp8 = (Scalar(1) / Scalar(2)) * _tmp4 + _tmp6 + 1;
  const Scalar _tmp9 = _tmp3 + _tmp5;
  const Scalar _tmp10 = std::pow<Scalar>(_tmp8, 2) / std::pow<Scalar>(_tmp9, 2);
  const Scalar _tmp11 = std::pow<Scalar>(_self[4], 2);
  const Scalar _tmp12 = _tmp10 * _tmp11 - _tmp11 + 1;

  // Output terms (2)
  Eigen::Matrix<Scalar, 2, 1> _pixel;

  _pixel(0, 0) = _self[0] * _tmp7 * point(0, 0) + _self[2];
  _pixel(1, 0) = _self[1] * _tmp7 * point(1, 0) + _self[3];

  if (is_valid != nullptr) {
    Scalar& _is_valid = (*is_valid);

    _is_valid = std::max<Scalar>(
        0,
        std::min<Scalar>(
            std::max<Scalar>(-(((_self[4] - 1) > 0) - ((_self[4] - 1) < 0)),
                             1 - std::max<Scalar>(0, -(((_self[4] * point(2, 0) + _tmp1) > 0) -
                                                       ((_self[4] * point(2, 0) + _tmp1) < 0)))),
            std::max<Scalar>(
                -(((_tmp12) > 0) - ((_tmp12) < 0)),
                1 - std::max<Scalar>(
                        0,
                        -(((-_tmp1 *
                                (_self[4] * _tmp10 - _self[4] -
                                 _tmp8 * std::sqrt(std::max<Scalar>(_tmp12, std::sqrt(epsilon))) /
                                     _tmp9) +
                            point(2, 0)) > 0) -
                          ((-_tmp1 *
                                (_self[4] * _tmp10 - _self[4] -
                                 _tmp8 * std::sqrt(std::max<Scalar>(_tmp12, std::sqrt(epsilon))) /
                                     _tmp9) +
                            point(2, 0)) < 0))))));
  }

  return _pixel;
}

template <typename Scalar>
Eigen::Matrix<Scalar, 3, 1> DoubleSphereCameraCal<Scalar>::CameraRayFromPixel(
    const Eigen::Matrix<Scalar, 2, 1>& pixel, const Scalar epsilon, Scalar* const is_valid) const {
  // Total ops: 75

  // Input arrays
  const Eigen::Matrix<Scalar, 6, 1>& _self = Data();

  // Intermediate terms (12)
  const Scalar _tmp0 = -_self[2] + pixel(0, 0);
  const Scalar _tmp1 = -_self[3] + pixel(1, 0);
  const Scalar _tmp2 = std::pow<Scalar>(_tmp1, 2) / std::pow<Scalar>(_self[1], 2) +
                       std::pow<Scalar>(_tmp0, 2) / std::pow<Scalar>(_self[0], 2);
  const Scalar _tmp3 = -_tmp2 * (2 * _self[5] - 1) + 1;
  const Scalar _tmp4 = _self[5] * std::sqrt(std::max<Scalar>(_tmp3, epsilon)) - _self[5] + 1;
  const Scalar _tmp5 =
      _tmp4 + epsilon * (2 * std::min<Scalar>(0, (((_tmp4) > 0) - ((_tmp4) < 0))) + 1);
  const Scalar _tmp6 = -std::pow<Scalar>(_self[5], 2) * _tmp2 + 1;
  const Scalar _tmp7 = _tmp6 / _tmp5;
  const Scalar _tmp8 = std::pow<Scalar>(_tmp6, 2) / std::pow<Scalar>(_tmp5, 2);
  const Scalar _tmp9 = _tmp2 * (1 - std::pow<Scalar>(_self[4], 2)) + _tmp8;
  const Scalar _tmp10 = _tmp2 + _tmp8;
  const Scalar _tmp11 =
      (_self[4] * _tmp7 + std::sqrt(std::max<Scalar>(_tmp9, epsilon))) /
      (_tmp10 + epsilon * (2 * std::min<Scalar>(0, (((_tmp10) > 0) - ((_tmp10) < 0))) + 1));

  // Output terms (2)
  Eigen::Matrix<Scalar, 3, 1> _camera_ray;

  _camera_ray(0, 0) = _tmp0 * _tmp11 / _self[0];
  _camera_ray(1, 0) = _tmp1 * _tmp11 / _self[1];
  _camera_ray(2, 0) = -_self[4] + _tmp11 * _tmp7;

  if (is_valid != nullptr) {
    Scalar& _is_valid = (*is_valid);

    _is_valid = std::min<Scalar>(1 - std::max<Scalar>(0, -(((_tmp3) > 0) - ((_tmp3) < 0))),
                                 1 - std::max<Scalar>(0, -(((_tmp9) > 0) - ((_tmp9) < 0))));
  }

  return _camera_ray;
}

}  // namespace sym

// Print implementations
std::ostream& operator<<(std::ostream& os, const sym::DoubleSphereCameraCald& a) {
  const Eigen::IOFormat fmt(Eigen::StreamPrecision, Eigen::DontAlignCols, ", ", "\n", "[", "]");
  os << "<DoubleSphereCameraCald " << a.Data().transpose().format(fmt) << ">";
  return os;
}
std::ostream& operator<<(std::ostream& os, const sym::DoubleSphereCameraCalf& a) {
  const Eigen::IOFormat fmt(Eigen::StreamPrecision, Eigen::DontAlignCols, ", ", "\n", "[", "]");
  os << "<DoubleSphereCameraCalf " << a.Data().transpose().format(fmt) << ">";
  return os;
}

// Concept implementations for this class
#include "./ops/double_sphere_camera_cal/storage_ops.cc"
